{
  "language": "Solidity",
  "sources": {
    "contracts/Bounty.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title Bounty\n * @dev A contract representing a single bug bounty with a locked amount of ETH.\n */\ncontract Bounty {\n    enum Status { Open, Submitted, Approved, Rejected, Disputed }\n\n    address public owner;\n    uint256 public amount;\n    string public cid; // IPFS CID for bounty details (title, description, severity)\n    Status public status;\n    string public reportCid; // IPFS CID for the researcher's submission\n    address public researcher;\n    uint256 public minStake = 0.01 ether; // minimum stake required to submit a report\n    uint256 public stakedAmount; // amount staked by the researcher for the current submission\n\n    event ReportSubmitted(address indexed researcher, string reportCid);\n    event SubmissionApproved(address indexed researcher);\n    event SubmissionRejected(address indexed researcher);\n    event FundsReleased(address indexed researcher, uint256 amount);\n    event StakeDeposited(address indexed researcher, uint256 amount);\n    event StakeRefunded(address indexed researcher, uint256 amount);\n    event StakeSlashed(address indexed researcher, uint256 amount, address indexed receiver);\n\n    constructor(address _owner, string memory _cid) payable {\n        require(msg.value > 0, \"Bounty amount cannot be zero\");\n        owner = _owner;\n        cid = _cid;\n        amount = msg.value;\n        status = Status.Open;\n    }\n\n    /**\n     * @dev Allows any address to submit a report for an open bounty.\n     * @param _reportCid The IPFS CID of the vulnerability report.\n     */\n    function submitReport(string memory _reportCid) external payable {\n        require(status == Status.Open, \"Bounty is not open for submissions\");\n        require(msg.value >= minStake, \"Insufficient stake\");\n        researcher = msg.sender;\n        reportCid = _reportCid;\n        status = Status.Submitted;\n        stakedAmount = msg.value;\n        emit StakeDeposited(msg.sender, msg.value);\n        emit ReportSubmitted(msg.sender, _reportCid);\n    }\n\n    /**\n     * @dev Allows the bounty owner to approve a submission and release funds.\n     */\n    function approveSubmission() external {\n        require(msg.sender == owner, \"Only bounty owner can approve\");\n        require(status == Status.Submitted, \"No submission to approve or already processed\");\n        status = Status.Approved;\n        uint256 _stake = stakedAmount;\n        stakedAmount = 0;\n        // Payout bounty amount\n        payable(researcher).transfer(amount);\n        // Refund stake to researcher\n        if (_stake > 0) {\n            payable(researcher).transfer(_stake);\n            emit StakeRefunded(researcher, _stake);\n        }\n        emit SubmissionApproved(researcher);\n        emit FundsReleased(researcher, amount);\n    }\n\n    /**\n     * @dev Allows the bounty owner to reject a submission.\n     */\n    function rejectSubmission() external {\n        require(msg.sender == owner, \"Only bounty owner can reject\");\n        require(status == Status.Submitted, \"No submission to reject or already processed\");\n        status = Status.Rejected;\n        uint256 _stake = stakedAmount;\n        stakedAmount = 0;\n        // Slash the researcher's stake and transfer to the owner as anti-spam penalty\n        if (_stake > 0) {\n            payable(owner).transfer(_stake);\n            emit StakeSlashed(researcher, _stake, owner);\n        }\n        emit SubmissionRejected(researcher);\n    }\n\n    /**\n     * @dev Allows the bounty owner to update the minimum stake required for submissions.\n     * @param _minStake The new minimum stake in wei.\n     */\n    function setMinStake(uint256 _minStake) external {\n        require(msg.sender == owner, \"Only bounty owner can set minStake\");\n        minStake = _minStake;\n    }\n}"
    },
    "contracts/BountyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./Bounty.sol\";\n\n/**\n * @title BountyFactory\n * @dev A factory contract to create and deploy new Bounty contracts.\n */\ncontract BountyFactory {\n    address[] public deployedBounties;\n\n    event BountyCreated(address indexed bountyAddress, address indexed owner, string cid, uint256 amount);\n\n    /**\n     * @dev Creates and deploys a new Bounty contract, funding it with the sent ETH.\n     * @param _owner The address that will own the new bounty.\n     * @param _cid The IPFS CID for the bounty's metadata.\n     * @return The address of the newly created Bounty contract.\n     */\n    function createBounty(address _owner, string memory _cid) external payable returns (address) {\n        // CRITICAL FIX: The `value: msg.value` forwards the ETH sent with this\n        // transaction to the new Bounty contract's constructor, funding it.\n        Bounty newBounty = new Bounty{value: msg.value}(_owner, _cid);\n        \n        address newBountyAddress = address(newBounty);\n        deployedBounties.push(newBountyAddress);\n        \n        emit BountyCreated(newBountyAddress, _owner, _cid, msg.value);\n        return newBountyAddress;\n    }\n\n    /**\n     * @dev Returns a list of all bounty contract addresses created by this factory.\n     */\n    function getDeployedBounties() external view returns (address[] memory) {\n        return deployedBounties;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}